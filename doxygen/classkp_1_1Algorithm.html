<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kompute: kp::Algorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kompute
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kp</b></li><li class="navelem"><a class="el" href="classkp_1_1Algorithm.html">Algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkp_1_1Algorithm-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kp::Algorithm Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Algorithm_8hpp_source.html">Algorithm.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae358eef3e05dd57eb57765c5d62c6655" id="r_ae358eef3e05dd57eb57765c5d62c6655"><td class="memTemplParams" colspan="2">template&lt;typename S  = float, typename P  = float&gt; </td></tr>
<tr class="memitem:ae358eef3e05dd57eb57765c5d62c6655"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#ae358eef3e05dd57eb57765c5d62c6655">Algorithm</a> (std::shared_ptr&lt; vk::Device &gt; device, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp;memObjects={}, const std::vector&lt; uint32_t &gt; &amp;spirv={}, const Workgroup &amp;workgroup={}, const std::vector&lt; S &gt; &amp;specializationConstants={}, const std::vector&lt; P &gt; &amp;pushConstants={}) noexcept</td></tr>
<tr class="separator:ae358eef3e05dd57eb57765c5d62c6655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7937ecea406e79660c1729dca4a263d" id="r_aa7937ecea406e79660c1729dca4a263d"><td class="memTemplParams" colspan="2">template&lt;typename S  = float, typename P  = float&gt; </td></tr>
<tr class="memitem:aa7937ecea406e79660c1729dca4a263d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#aa7937ecea406e79660c1729dca4a263d">rebuild</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp;memObjects, const std::vector&lt; uint32_t &gt; &amp;spirv, const Workgroup &amp;workgroup={}, const std::vector&lt; S &gt; &amp;specializationConstants={}, const std::vector&lt; P &gt; &amp;pushConstants={})</td></tr>
<tr class="separator:aa7937ecea406e79660c1729dca4a263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a335291407f83404db43a9ae188fe" id="r_a251a335291407f83404db43a9ae188fe"><td class="memItemLeft" align="right" valign="top"><a id="a251a335291407f83404db43a9ae188fe" name="a251a335291407f83404db43a9ae188fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Algorithm</b> (const <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;)=delete</td></tr>
<tr class="memdesc:a251a335291407f83404db43a9ae188fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> uncopyable. <br /></td></tr>
<tr class="separator:a251a335291407f83404db43a9ae188fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19504dc5b251146b639b1bfba124b4a" id="r_ad19504dc5b251146b639b1bfba124b4a"><td class="memItemLeft" align="right" valign="top"><a id="ad19504dc5b251146b639b1bfba124b4a" name="ad19504dc5b251146b639b1bfba124b4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Algorithm</b> (const <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad19504dc5b251146b639b1bfba124b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097573506441ad7d1dcd83e4f3529428" id="r_a097573506441ad7d1dcd83e4f3529428"><td class="memItemLeft" align="right" valign="top"><a id="a097573506441ad7d1dcd83e4f3529428" name="a097573506441ad7d1dcd83e4f3529428"></a>
<a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;)=delete</td></tr>
<tr class="separator:a097573506441ad7d1dcd83e4f3529428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb356746eaf4e548597047cc8a01b60" id="r_a1fb356746eaf4e548597047cc8a01b60"><td class="memItemLeft" align="right" valign="top"><a id="a1fb356746eaf4e548597047cc8a01b60" name="a1fb356746eaf4e548597047cc8a01b60"></a>
<a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1fb356746eaf4e548597047cc8a01b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eea604f380bd20385dcd15ebfd82bf" id="r_a16eea604f380bd20385dcd15ebfd82bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a16eea604f380bd20385dcd15ebfd82bf">~Algorithm</a> () noexcept</td></tr>
<tr class="separator:a16eea604f380bd20385dcd15ebfd82bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee096b6a4f8ae46f62273220c35423" id="r_aa8ee096b6a4f8ae46f62273220c35423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#aa8ee096b6a4f8ae46f62273220c35423">recordDispatch</a> (const vk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="separator:aa8ee096b6a4f8ae46f62273220c35423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02656689952580a83d5f8d2c769a041e" id="r_a02656689952580a83d5f8d2c769a041e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a02656689952580a83d5f8d2c769a041e">recordBindCore</a> (const vk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="separator:a02656689952580a83d5f8d2c769a041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3277dff114031c091475a12fb3cd23" id="r_a4e3277dff114031c091475a12fb3cd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a4e3277dff114031c091475a12fb3cd23">recordBindPush</a> (const vk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="separator:a4e3277dff114031c091475a12fb3cd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974ac8dd9f100fd4ed3ef71312314bda" id="r_a974ac8dd9f100fd4ed3ef71312314bda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a974ac8dd9f100fd4ed3ef71312314bda">isInit</a> ()</td></tr>
<tr class="separator:a974ac8dd9f100fd4ed3ef71312314bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f195f84f2e30d5913776a6610c52c19" id="r_a3f195f84f2e30d5913776a6610c52c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a3f195f84f2e30d5913776a6610c52c19">setWorkgroup</a> (const Workgroup &amp;workgroup, uint32_t minSize=1)</td></tr>
<tr class="separator:a3f195f84f2e30d5913776a6610c52c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9565ad7fd9ec76ef2b4ca39385dae" id="r_a45c9565ad7fd9ec76ef2b4ca39385dae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45c9565ad7fd9ec76ef2b4ca39385dae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a45c9565ad7fd9ec76ef2b4ca39385dae">setPushConstants</a> (const std::vector&lt; T &gt; &amp;pushConstants)</td></tr>
<tr class="separator:a45c9565ad7fd9ec76ef2b4ca39385dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3e21c65a28772e01c8ef45794a1943" id="r_aac3e21c65a28772e01c8ef45794a1943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#aac3e21c65a28772e01c8ef45794a1943">setPushConstants</a> (void *data, uint32_t size, uint32_t memorySize)</td></tr>
<tr class="separator:aac3e21c65a28772e01c8ef45794a1943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa439adf43009dabb251ca853a9f5abe3" id="r_aa439adf43009dabb251ca853a9f5abe3"><td class="memItemLeft" align="right" valign="top">const Workgroup &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#aa439adf43009dabb251ca853a9f5abe3">getWorkgroup</a> ()</td></tr>
<tr class="separator:aa439adf43009dabb251ca853a9f5abe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f3bb70edc8a175c52023bf7327cec7" id="r_a14f3bb70edc8a175c52023bf7327cec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14f3bb70edc8a175c52023bf7327cec7"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a14f3bb70edc8a175c52023bf7327cec7">getSpecializationConstants</a> ()</td></tr>
<tr class="separator:a14f3bb70edc8a175c52023bf7327cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651844c967669390350db6a0f6c9f29" id="r_ae651844c967669390350db6a0f6c9f29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae651844c967669390350db6a0f6c9f29"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#ae651844c967669390350db6a0f6c9f29">getPushConstants</a> ()</td></tr>
<tr class="separator:ae651844c967669390350db6a0f6c9f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d70d7231ca5c404494f11c8f6bb0b2d" id="r_a1d70d7231ca5c404494f11c8f6bb0b2d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Algorithm.html#a1d70d7231ca5c404494f11c8f6bb0b2d">getMemObjects</a> ()</td></tr>
<tr class="separator:a1d70d7231ca5c404494f11c8f6bb0b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38b14c24a26bd2eef13d8cb8e97214a" id="r_af38b14c24a26bd2eef13d8cb8e97214a"><td class="memItemLeft" align="right" valign="top"><a id="af38b14c24a26bd2eef13d8cb8e97214a" name="af38b14c24a26bd2eef13d8cb8e97214a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> ()</td></tr>
<tr class="separator:af38b14c24a26bd2eef13d8cb8e97214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction for compute shaders that are run on top of tensors grouped via ParameterGroups (which group descriptorsets) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae358eef3e05dd57eb57765c5d62c6655" name="ae358eef3e05dd57eb57765c5d62c6655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae358eef3e05dd57eb57765c5d62c6655">&#9670;&#160;</a></span>Algorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S  = float, typename P  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kp::Algorithm::Algorithm </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::Device &gt;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>memObjects</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>spirv</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Workgroup &amp;&#160;</td>
          <td class="paramname"><em>workgroup</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>specializationConstants</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>pushConstants</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Main constructor for algorithm with configuration parameters to create the underlying resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The Vulkan device to use for creating resources </td></tr>
    <tr><td class="paramname">tensors</td><td>(optional) The tensors to use to create the descriptor resources </td></tr>
    <tr><td class="paramname">spirv</td><td>(optional) The spirv code to use to create the algorithm </td></tr>
    <tr><td class="paramname">workgroup</td><td>(optional) The kp::Workgroup to use for the dispatch which defaults to kp::Workgroup(tensor[0].size(), 1, 1) if not set. </td></tr>
    <tr><td class="paramname">specializationConstants</td><td>(optional) The templatable param is to be used to initialize the specialization constants which cannot be changed once set. </td></tr>
    <tr><td class="paramname">pushConstants</td><td>(optional) This templatable param is to be used when initializing the pipeline, which set the size of the push constants<ul>
<li>these can be modified but all new values must have the same data type and length as otherwise it will result in errors. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16eea604f380bd20385dcd15ebfd82bf" name="a16eea604f380bd20385dcd15ebfd82bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16eea604f380bd20385dcd15ebfd82bf">&#9670;&#160;</a></span>~Algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kp::Algorithm::~Algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor for <a class="el" href="classkp_1_1Algorithm.html">Algorithm</a> which is responsible for freeing and desroying respective pipelines and owned parameter groups. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d70d7231ca5c404494f11c8f6bb0b2d" name="a1d70d7231ca5c404494f11c8f6bb0b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d70d7231ca5c404494f11c8f6bb0b2d">&#9670;&#160;</a></span>getMemObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp; kp::Algorithm::getMemObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current memory objects that are used in the algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>The list of memory objects used in the algorithm. </dd></dl>

</div>
</div>
<a id="ae651844c967669390350db6a0f6c9f29" name="ae651844c967669390350db6a0f6c9f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae651844c967669390350db6a0f6c9f29">&#9670;&#160;</a></span>getPushConstants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; kp::Algorithm::getPushConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the specialization constants of the current algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>The std::vector&lt;float&gt; currently set for push constants </dd></dl>

</div>
</div>
<a id="a14f3bb70edc8a175c52023bf7327cec7" name="a14f3bb70edc8a175c52023bf7327cec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f3bb70edc8a175c52023bf7327cec7">&#9670;&#160;</a></span>getSpecializationConstants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; kp::Algorithm::getSpecializationConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the specialization constants of the current algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>The std::vector&lt;float&gt; currently set for specialization constants </dd></dl>

</div>
</div>
<a id="aa439adf43009dabb251ca853a9f5abe3" name="aa439adf43009dabb251ca853a9f5abe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa439adf43009dabb251ca853a9f5abe3">&#9670;&#160;</a></span>getWorkgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Workgroup &amp; kp::Algorithm::getWorkgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current workgroup from the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>kp::Constant to use to set the push constants to use in the next bindPush(...) calls. The constants provided must be of the same size as the ones created during initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a974ac8dd9f100fd4ed3ef71312314bda" name="a974ac8dd9f100fd4ed3ef71312314bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974ac8dd9f100fd4ed3ef71312314bda">&#9670;&#160;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kp::Algorithm::isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function that checks all the gpu resource components to verify if these have been created and returns true if all are valid.</p>
<dl class="section return"><dt>Returns</dt><dd>returns true if the algorithm is currently initialized. </dd></dl>

</div>
</div>
<a id="aa7937ecea406e79660c1729dca4a263d" name="aa7937ecea406e79660c1729dca4a263d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7937ecea406e79660c1729dca4a263d">&#9670;&#160;</a></span>rebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S  = float, typename P  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::rebuild </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classkp_1_1Memory.html">Memory</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>memObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>spirv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Workgroup &amp;&#160;</td>
          <td class="paramname"><em>workgroup</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>specializationConstants</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>pushConstants</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebuild function to reconstruct algorithm with configuration parameters to create the underlying resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensors</td><td>The tensors to use to create the descriptor resources </td></tr>
    <tr><td class="paramname">spirv</td><td>The spirv code to use to create the algorithm </td></tr>
    <tr><td class="paramname">workgroup</td><td>(optional) The kp::Workgroup to use for the dispatch which defaults to kp::Workgroup(tensor[0].size(), 1, 1) if not set. </td></tr>
    <tr><td class="paramname">specializationConstants</td><td>(optional) The std::vector&lt;float&gt; to use to initialize the specialization constants which cannot be changed once set. </td></tr>
    <tr><td class="paramname">pushConstants</td><td>(optional) The std::vector&lt;float&gt; to use when initializing the pipeline, which set the size of the push constants - these can be modified but all new values must have the same vector size as this initial value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02656689952580a83d5f8d2c769a041e" name="a02656689952580a83d5f8d2c769a041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02656689952580a83d5f8d2c769a041e">&#9670;&#160;</a></span>recordBindCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::recordBindCore </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records command that binds the "core" algorithm components which consist of binding the pipeline and binding the descriptorsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Command buffer to record the algorithm resources to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e3277dff114031c091475a12fb3cd23" name="a4e3277dff114031c091475a12fb3cd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3277dff114031c091475a12fb3cd23">&#9670;&#160;</a></span>recordBindPush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::recordBindPush </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records command that binds the push constants to the command buffer provided</p><ul>
<li>it is required that the pushConstants provided are of the same size as the ones provided during initialization.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Command buffer to record the algorithm resources to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8ee096b6a4f8ae46f62273220c35423" name="aa8ee096b6a4f8ae46f62273220c35423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ee096b6a4f8ae46f62273220c35423">&#9670;&#160;</a></span>recordDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::recordDispatch </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the dispatch function with the provided template parameters or alternatively using the size of the tensor by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Command buffer to record the algorithm resources to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45c9565ad7fd9ec76ef2b4ca39385dae" name="a45c9565ad7fd9ec76ef2b4ca39385dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9565ad7fd9ec76ef2b4ca39385dae">&#9670;&#160;</a></span>setPushConstants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::setPushConstants </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pushConstants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the push constants to the new value provided to use in the next bindPush()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pushConstants</td><td>The templatable vector is to be used to set the push constants to use in the next bindPush(...) calls. The constants provided must be of the same size as the ones created during initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac3e21c65a28772e01c8ef45794a1943" name="aac3e21c65a28772e01c8ef45794a1943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3e21c65a28772e01c8ef45794a1943">&#9670;&#160;</a></span>setPushConstants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::setPushConstants </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the push constants to the new value provided to use in the next bindPush() with the raw memory block location and memory size to be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The raw data point to copy the data from, without modifying the pointer. </td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements provided in the data </td></tr>
    <tr><td class="paramname">memorySize</td><td>The memory size of each of the data elements in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f195f84f2e30d5913776a6610c52c19" name="a3f195f84f2e30d5913776a6610c52c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f195f84f2e30d5913776a6610c52c19">&#9670;&#160;</a></span>setWorkgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Algorithm::setWorkgroup </td>
          <td>(</td>
          <td class="paramtype">const Workgroup &amp;&#160;</td>
          <td class="paramname"><em>workgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the work group to use in the recordDispatch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workgroup</td><td>The kp::Workgroup value to use to update the algorithm. It must have a value greater than 1 on the x value (index 1) otherwise it will be initialized on the size of the first tensor (ie. this-&gt;mTensor[0]-&gt;size()) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/me/development/kompute/src/include/kompute/<a class="el" href="Algorithm_8hpp_source.html">Algorithm.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
